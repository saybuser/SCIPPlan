# SCIPPlan

SCIPPlan [1,2,3] is a SCIP-based [4] hybrid planner for domains with i) mixed (i.e., real and/or discrete valued) state and action spaces, ii) nonlinear state transitions that are functions of time, and iii) general reward functions. SCIPPlan iteratively i) finds violated constraints (i.e., zero-crossings) by simulating the state transitions, and ii) adds the violated (symbolic) constraints back to its underlying optimisation model, until a valid plan is found.

## Example Domain: Navigation

<img src=./visualisation/scipplan_navigation_1.gif width="32%" height="32%"> <img src=./visualisation/scipplan_navigation_2.gif width="32%" height="32%"> <img src=./visualisation/scipplan_navigation_3.gif width="32%" height="32%">


Figure 1: Visualisation of different plans generated by SCIPPlan [1,2,3] for example navigation domains where the red square represents the agent, the blue shapes represent the obstacles, the gold star represents the goal location and the delta represents time. The agent can control its acceleration and the duration of its control input to modify its speed and location in order to navigate in a two-dimensional maze. The purpose of the domain is to find a path for the agent with minimum makespan such that the agent reaches its the goal without colliding with the obstacles. 

Note that SCIPPlan does not linearise or discretise the domain to find a valid plan.

## Dependencies

i) Solver: SCIP (the current implementation uses the python interface to the SCIP solver, i.e., PySCIPOpt [5]). This version of SCIPPlan has only been tested on PySCIOpt>=4.0.0 using earlier an version of pyscipopt may result in unintended behaviour. 

## Installing and Running SCIPPlan
In order to Install SCIPPlan you need to ensure you have a working version of the SCIP optimisation suite on your system which can be installed from [the SCIP website](https://www.scipopt.org). For more information about SCIP and PySCIPOpt refer to this [installation guide](https://github.com/scipopt/PySCIPOpt/blob/master/INSTALL.md).

After installing SCIP you will be able to install SCIPPlan using
```bash
pip install scipplan
```
Now you will be able to run some of the example domains which include 
- Navigation (3 instances)

To run one of these examples all you need to do is run
```bash
scipplan -D navigation -I 1
```
which will run the 1st instance of the navigation domain. For more information regarding the available tags and what they mean run `scipplan --help`.

Alternatively you can import scipplan classes to run it using python.
```py
from scipplan.scipplan import SCIPPlan
from scipplan.config import Config
from scipplan.helpers import write_to_csv
```
this will import the only 2 classes and function needed to run SCIPPlan. Then to set the configuration either create an instance of the Config class by setting the params or by retrieving the cli input
```py
# Set params
config = Config(domain="navigation", instance=1)
# Retrieve cli args
config = Config.get_config()
```
after which you are able to solve problem by either using the solve or optimize methods
```py
# The optimize method just optimises the problem for the given horizon
plan = SCIPPlan(config)
plan.optimize()
# Class method which takes input the config, solves the problem 
# with auto incrementing the horizon until a solution is found then 
# returns the plan as well as the time taken to solve the problem
plan, solve_time = SCIPPlan.solve(config)  
```
In order to save the generated constraints for the horizon solved as well as the results, use the following code
```py
write_to_csv("new_constraints", plan.new_constraints, config)
write_to_csv("results", plan.results_table, config)
```



## Custom Domains
If you would like to create your own domain you will need to create a directory named "translation" in the directory which scipplan is run from with txt files of the format "{domain_type}\_{domain name}\_{instance number}.txt" (e.g. "odes_navigation_1.txt", with available domain types, `odes` and `solutions`). Note that the files in the translation directory will override any example files if they share domain name and instance number (e.g. `solutions_navigation_1` would override the example).

This file contains sections for the various translations listed, these sections are separated by `---` and contain a header which is the name of the section (e.g. `pvariables:`). The required sections are as follows
- constants
- pvariables
- transitions (for `solutions`)/odes (for `odes`)
- initials
- goals
- instantaneous_constraints
- temporal_constraints
- reward

As a part of SCIPPlan, all the constraint files allow for the use of "and" and "or" expressions, polynomials and `exp`, `log`, `sqrt`, `sin` and `cos` functions (Note: `sin` and `cos` are only available in PySCIPOpt>=4.3.0 so if your version is below that you will not be able to use the trig functions unless you update).

### Constants
The constants file allows for constant values to be defined as a variable to be used in other files in the model. To use add constants as follows
```txt
constants:
HalfVal = 0.5
Epsilon = config_epsilon
bigM = config_bigM
```  

Some config values can be accessed in the constants file to be used in other files and are available as 
- `config_epsilon`
- `config_gap`
- `config_bigM`  
Note that these variables are only accessible in the constants file and you will need to define a new constants variable to store the value 

### Pvariables
When creating the pvariables file, the variables should be listed in the following format
```txt
pvariables:
action_continuous: Accelerate_x
action_continuous: Accelerate_y
action_continuous: Dt
action_boolean: Mode
state_continuous: Location_x
state_continuous: Location_y
state_continuous: Speed_x
state_continuous: Speed_y
global_boolean: aux_1
```
where the variable and value type of the variable is set in the format "{variable type}_{value type}" and the variable itself has to be in a Python compatible format (e.g. variables can't use - symbol like `some-var` but can use _ like `some_var` as well as the dash sign ' cannot be used). The use of next state variables which is often written using the dash symbol will be explained further in the Transitions section.  
Additionally a variable for Dt has to be defined and has to be the same as the dt_var in the config object so if you would like to use a different variable name for Dt (e.g. dt) please also ensure you add it to the config via the `--dt-var` tag or the `dt_var` parameter.  
The variable type `global` is used when you would like a non state variable to be equal over every time step over the horizon (e.g. if $v_t$ is a variable at time $t$ and $H$ is the horizon, then $v_1 = v_2 = \dots = v_{H+1}$).  

The available variable types are
- state
- action
- auxiliary
- global

The available value types are 
- continuos
- integer 
- boolean 

Please note that constants don't need to have their variable names defined in pvariables as they are defined in constants.  

### Transitions (For Solutions)
Transitions are to be added here with the following syntax.  
For example $S_{t+1} = \frac 12 A_t\cdot t^2 + V_t\cdot t + S_t$.  
Alternatively this can be written as $S' = \frac 12 A\cdot t^2 + V\cdot t + S$.
Since Python doesn't allow variables to use the ' symbol it should be replaced with `_dash`, for example
```txt
transitions:
Location_x_dash - 1.0*Location_x - 1.0*Speed_x*(Dt + Epsilon*Mode) - 0.5*Accelerate_x*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) == 0.0
Location_y_dash - 1.0*Location_y - 1.0*Speed_y*(Dt + Epsilon*Mode) - 0.5*Accelerate_y*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) == 0.0
Speed_x_dash - 1.0*Speed_x - 1.0*Accelerate_x*(Dt + Epsilon*Mode) == 0.0
Speed_y_dash - 1.0*Speed_y - 1.0*Accelerate_y*(Dt + Epsilon*Mode) == 0.0
```

### ODEs (For ODEs)
When providing a system of odes to be solved, they are to be provided as follows
```txt
odes:
dd(Location_x, Dt) == Speed_x
dd(Location_y, Dt) == Speed_y
dd(Speed_x, Dt) == Accelerate_x
dd(Speed_y, Dt) == Accelerate_y
```  

Note that `dd(y(t), t)` is equivalent to $\frac{\partial y(t)}{\partial t}$.

Additionally, since we utilise SymPy to solve the system of odes, be aware of which systems have a solution which SymPy can solve for.  


### Initials
The initials file defines the initial state values for time t=0, for example
```txt
initials:
Location_x == 0.0
Location_y == 0.0
Speed_x == 0.0
Speed_y == 0.0
```
notice the use of the constant value defined earlier in the constants file.
### Goals
The goals file should encode the final state values such that t=H+1, for example
```txt
goals:
Location_x == 8.0
Location_y == 8.0
```
### Instantaneous Constraints
This is where the instantaneous constraints go.
An example is as follows
```txt
instantaneous_constraints:
Location_x <= 10.0
Location_y <= 10.0
Location_x >= 0.0
Location_y >= 0.0
Accelerate_x <= 0.5
Accelerate_y <= 0.5
Accelerate_x >= -0.5
Accelerate_y >= -0.5
(Location_x <= 4.0) or (Location_x >= 6.0) or (Location_y <= 4.0) or (Location_y >= 6.0)
```
### Temporal Constraints
The temporal constraints are the constraints which SCIPPlan will ensure that the solution never violates by iterating through every epsilon value of Dt and checking for zero crossings. An example of a temporal constraint is as follows
```txt
temporal_constraints:
Location_x + Speed_x*(Dt + Epsilon*Mode) + 0.5*Accelerate_x*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) <= 10.0
Location_y + Speed_y*(Dt + Epsilon*Mode) + 0.5*Accelerate_y*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) <= 10.0
Location_x + Speed_x*(Dt + Epsilon*Mode) + 0.5*Accelerate_x*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) >= 0.0
Location_y + Speed_y*(Dt + Epsilon*Mode) + 0.5*Accelerate_y*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) >= 0.0

((Location_x + Speed_x*(Dt + Epsilon*Mode) + 0.5*Accelerate_x*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) <= 4.0) or 
(Location_x + Speed_x*(Dt + Epsilon*Mode) + 0.5*Accelerate_x*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) >= 6.0) or 
(Location_y + Speed_y*(Dt + Epsilon*Mode) + 0.5*Accelerate_y*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) <= 4.0) or 
(Location_y + Speed_y*(Dt + Epsilon*Mode) + 0.5*Accelerate_y*(Dt + Epsilon*Mode)*(Dt + Epsilon*Mode) >= 6.0))
```

The use of mode switches are used in these constraints (`Dt + Epsilon*Mode`). Please note that the or expression is enclosed in round brackets which allows the constraints to be parsed as a singular expression.  

Furthermore, when providing a system of odes over solution equations, the state variable can be used in this file and it is later substituted with the solution equations. For example
```txt
temporal_constraints:
Location_x <= 10.0
Location_y <= 10.0
Location_x >= 0.0
Location_y >= 0.0
```  

### Reward
As for the reward function, SCIPPlan maximises the reward thus if using a cost function it should be negated as per the example
```txt
reward:
-1.0*(Dt + Mode * Epsilon)
```
Only one reward function is able to be optimised for in SCIPPlan

## Citation

If you are using SCIPPlan, please cite the papers [1,2,3] and the underlying SCIP solver [4].

## References
[1] Buser Say and Scott Sanner. [Metric Nonlinear Hybrid Planning with Constraint Generation](http://icaps18.icaps-conference.org/fileadmin/alg/conferences/icaps18/workshops/workshop06/docs/proceedings.pdf#page=23). In PlanSOpt, pages 19-25, 2018.

[2] Buser Say and Scott Sanner. [Metric Hybrid Factored Planning in Nonlinear Domains with Constraint Generation](https://link.springer.com/chapter/10.1007/978-3-030-19212-9_33). In CPAIOR, pages 502-518, 2019.

[3] Buser Say. [Robust Metric Hybrid Planning in Stochastic Nonlinear Domains Using Mathematical Optimization](https://ojs.aaai.org/index.php/ICAPS/article/view/27216). In ICAPS, pages 375-383, 2023.

[4] [SCIP](https://www.scipopt.org/)

[5] [PySCIPOpt](https://github.com/SCIP-Interfaces/PySCIPOpt)
